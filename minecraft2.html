<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Random Terrain with Labels</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
    <!-- Three.js 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
    <script src="MV.js"></script>
    <script type="importmap">
        {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
        }
        </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const roadColor = 0x808080; // 회색 도로 색상
        const buildingAreaColors = [0x3b5998, 0x8b9dc3, 0xdfe3ee, 0xf7f7f7]; // 건물 밀집 구역 색상
        const cars = [];
        const weatherParticles = [];
        let weatherState = 'clear';


        class Chunk {
            constructor(x, z, size) {
                this.x = x * size;  // 절대 좌표로 설정
                this.z = z * size;
                this.size = size;
                this.roadWidth = 3; // 도로 두께
                this.mesh = new THREE.Group(); // 청크 내 여러 Mesh를 그룹으로 관리
                this.buildings = [];
                this.cars = [];
                // 도로 및 교차로 배치(intersection 만들기 위해 사용)
                this.roadPositionsX = [];
                this.roadPositionsZ = [];
                // 도로 경계를 저장할 배열
                this.roadsL = [];
                this.roadsR = [];
                this.roadsT = [];
                this.roadsB = [];
                //4개의 교차로를 저장할 배열
                this.intersectionRB= new Set();//roadsR, roadsB를 비교
                this.intersectionRT= new Set();
                this.intersectionLB= new Set();
                this.intersectionLT= new Set();
                this.intersectionBB= new Set();
                this.intersectionTT= new Set();

                this.label = this.getRandomLabel(); // 랜덤 라벨 생성
                this.buildingColor = buildingAreaColors[this.label]; // 라벨에 따른 건물 색상
                
                this.generateChunk();
            }
            // 랜덤 라벨을 반환하는 함수 (0 ~ 3)
            getRandomLabel() {
                return Math.floor(Math.random() * 4);
            }
            // 청크 생성
            generateChunk() {
                // 상하좌우 도로 생성
                this.createBorderRoads();
                
                // 청크를 꽉 채우는 건물 밀집 구역 생성
                this.fillWithBuildingAreas();

                //교차로 생성
                this.createIntersections();

                //도로위에 차 생성
                

                //건물생성

            }

            // 상하좌우 도로를 생성하는 함수
            createBorderRoads() {
                const roadMaterial = new THREE.MeshLambertMaterial({ color: roadColor });
                roadMaterial.receiveShadow = true;
                // 상단 도로
                let roadGeometry = new THREE.PlaneGeometry(this.size, this.roadWidth);
                roadGeometry.rotateX(-Math.PI / 2);
                let road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.position.set(this.x + this.size / 2, 0.1, this.z + this.size - this.roadWidth / 2);
                this.mesh.add(road);

                // 하단 도로
                road = road.clone();
                road.position.set(this.x + this.size / 2, 0.1, this.z + this.roadWidth / 2);
                this.mesh.add(road);

                // 좌측 도로
                roadGeometry = new THREE.PlaneGeometry(this.roadWidth, this.size);
                roadGeometry.rotateX(-Math.PI / 2);
                road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.position.set(this.x + this.roadWidth / 2, 0.1, this.z + this.size / 2);
                this.mesh.add(road);

                // 우측 도로
                road = road.clone();
                road.position.set(this.x + this.size - this.roadWidth / 2, 0.1, this.z + this.size / 2);
                this.mesh.add(road);
            }

            // 청크를 꽉 채우는 건물 밀집 구역을 반복해서 생성
            fillWithBuildingAreas() {
                const buildingAreaMaterial = new THREE.MeshLambertMaterial({ color: this.buildingColor });
                const roadMaterial = new THREE.MeshLambertMaterial({ color: roadColor });
                const roadWidth = this.roadWidth;

                let currentX = this.x + roadWidth;
                let currentZ = this.z + roadWidth;
                // 5개의 랜덤한 X 크기 생성 (건물 너비)
                const xValues = this.generateRandomSizes(this.size - 2 * roadWidth, 5, 40, 100);

                // X축을 따라 건물 배치
                for (let i = 0; i < xValues.length; i++) {
                    const xWidth = xValues[i];
                    currentZ = this.z+ roadWidth;  // Z축을 다시 처음 위치로 리셋

                    // 5개의 랜덤한 Z 크기 생성 (건물 깊이)
                    const zValues = this.generateRandomSizes(this.size - 2 * roadWidth, 5, 40, 100);
                    // Z축을 따라 건물 배치
                    for (let j = 0; j < zValues.length; j++) {
                        const zDepth = zValues[j];

                        // 도로를 그리는 함수 호출
                        this.createRoads(currentX+roadWidth, currentZ, xWidth, zDepth, roadWidth, roadMaterial);

                        // 건물 밀집 구역 생성
                        const buildingAreaGeometry = new THREE.PlaneGeometry(xWidth - 2 * roadWidth, zDepth - 2 * roadWidth);
                        buildingAreaGeometry.rotateX(-Math.PI / 2); // 평면을 위로 돌림
                        const buildingArea = new THREE.Mesh(buildingAreaGeometry, buildingAreaMaterial);
                        buildingArea.position.set(currentX + xWidth / 2, 0.1, currentZ + zDepth / 2);
                        this.mesh.add(buildingArea);

                        currentZ += zDepth; // 다음 Z축으로 이동
                    }

                    currentX += xWidth; // 다음 X축으로 이동
                }
            }
            createRoads(x, z, width, depth, roadWidth, roadMaterial) {
                const roadGeometryX = new THREE.PlaneGeometry(width, roadWidth);  // 가로 도로용
                const roadGeometryZ = new THREE.PlaneGeometry(roadWidth, depth-2*roadWidth);  // 세로 도로용
            
                roadGeometryX.rotateX(-Math.PI / 2);
                roadGeometryZ.rotateX(-Math.PI / 2);
            
                // 상단 도로
                const topRoad = new THREE.Mesh(roadGeometryX, new THREE.MeshLambertMaterial({ color: 0xcf3213 }));//빨
                topRoad.position.set(x + width / 2-roadWidth, 0.1, z + depth - roadWidth / 2);
                this.mesh.add(topRoad);
                // 도로 경계 저장 (도로 충돌 감지용)
                this.roadsT.push({
                    x:(x + width / 2-roadWidth),z:z + depth - roadWidth / 2,width: width,depth: depth
                });
            
                // 하단 도로
                const bottomRoad = new THREE.Mesh(roadGeometryX, new THREE.MeshLambertMaterial({ color: 0xfcba03}));//노
                bottomRoad.position.set(x + width / 2-roadWidth, 0.1, z + roadWidth / 2);
                this.mesh.add(bottomRoad);
                // 도로 경계 저장 (도로 충돌 감지용)
                
                this.roadsB.push({x:x + width / 2-roadWidth ,z: z + roadWidth / 2,width: width,depth: depth});
            
                // 좌측 도로
                const leftRoad = new THREE.Mesh(roadGeometryZ, new THREE.MeshLambertMaterial({ color: 0x0fd166 })); //초
                leftRoad.position.set(x + width - 3*roadWidth/2, 0.1, z + depth / 2);
                this.mesh.add(leftRoad);
                // 도로 경계 저장 (도로 충돌 감지용)
                this.roadsL.push({x:x + width - 3*roadWidth/2 ,z: z + depth / 2,width: width,depth: depth});

                // 우측 도로
                const rightRoad = new THREE.Mesh(roadGeometryZ, new THREE.MeshLambertMaterial({ color: 0x1c23ad }));//파
                rightRoad.position.set(x - roadWidth / 2 , 0.1, z + depth / 2);
                this.mesh.add(rightRoad);

                // 도로 경계 저장 (도로 충돌 감지용)
                this.roadsR.push({x:x - roadWidth / 2,z: z + depth / 2,width: width,depth: depth});
            }

            // 교차로 생성 함수
            createIntersections() {
                const intersectionMaterial = new THREE.MeshLambertMaterial({ color: 0x11311d });
                const intersectionGeometry = new THREE.BoxGeometry(this.roadWidth, 0.1, this.roadWidth);

                for (let r of this.roadsR){
                    for(let t of this.roadsT){
                        
                        if(r.x+this.roadWidth/2 == t.x - t.width/2 + this.roadWidth){
                            
                            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                            intersection.position.set(r.x,0.1,r.z+r.depth/2+this.roadWidth/2-this.roadWidth);
                            this.mesh.add(intersection);
                            this.intersectionRT.add(intersection);
                        }
                    }
                }
                for (let r of this.roadsR){
                    for(let b of this.roadsB){
                        if(r.x+this.roadWidth/2 == b.x - b.width/2 + this.roadWidth){
                            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                            intersection.position.set(r.x,0.1,r.z-r.depth/2+this.roadWidth/2);
                            this.mesh.add(intersection);
                            //console.log(intersection.position);
                            this.intersectionRB.add(intersection);
                        }
                    }
                }
                for (let l of this.roadsL){
                    for(let b of this.roadsB){
                        if(l.x-l.width+3*this.roadWidth/2 == b.x-b.width/2 + this.roadWidth){
                            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                            intersection.position.set(l.x,0.1,l.z-l.depth/2+this.roadWidth-this.roadWidth/2);
                            this.mesh.add(intersection);
                            //console.log(intersection.position);
                            this.intersectionLB.add(intersection);
                        }
                    }
                }
                for (let l of this.roadsL){
                    for(let t of this.roadsT){
                        if(t.x - t.width/2 + this.roadWidth == l.x-l.width+3*this.roadWidth/2){
                            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                            intersection.position.set(l.x,0.1,l.z-l.depth/2+-this.roadWidth/2+l.depth);
                            this.mesh.add(intersection);
                            //console.log(intersection.position);
                            this.intersectionLB.add(intersection);
                        }
                    }
                }

                for (let bL of this.roadsB){
                    for(let bR of this.roadsB){
                        if(bR.x == bL.x+bL.depth){
                            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                            intersection.position.set(bR.x,1,bR.y);
                            this.mesh.add(intersection);
                            //console.log(intersection.position);
                            this.intersectionBB.add(intersection); 
                        }
                    }
                }
                for (let tL of this.roadsT){
                    for(let tR of this.roadsT){
                        if(tR.x == tL.x+tL.depth){
                            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                            intersection.position.set(tR.x,1,tR.y);
                            this.mesh.add(intersection);
                            //console.log(intersection.position);
                            this.intersectionTT.add(intersection);
                        }
                    }
                }
            }

            

            generateRandomSizes(sum, count, min, max) {
                const sizes = [];
                let total = 0;
            
                // 값들을 먼저 min으로 채우고, 그 다음으로 남은 값을 분배
                for (let i = 0; i < count; i++) {
                    sizes.push(min);
                    total += min;
                }
            
                let remaining = sum - total;
            
                // 남은 값을 랜덤하게 각 사이즈에 분배 (정수로 처리)
                while (remaining > 0) {
                    for (let i = 0; i < count && remaining > 0; i++) {
                        const add = Math.min(remaining, Math.floor(Math.random() * (max - min + 1)));
                        sizes[i] += add;
                        remaining -= add;
                    }
                }
            
                return sizes;
            }
            createCars(numberOfCars){
                for(let i=0;i<numberOfCars;i++){

                    //0이면 rightroads
                    //1이면 leftroads
                    //2이면 toproads
                    //3이면 bottomroads
                    const roadIndex = Math.floor(Math.random()*4);
                    let car;
                    
                    if(roadIndex==0){
                        //roadsR[]에서 랜덤으로 하나
                        const randomElement = this.roadsR[Math.floor(Math.random() * array.length)];
                        car = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                        car.position.set(randomElement.x, 0.5, randomElement.z); 
                        car.direction = 'north';                        
                    } else if(roadIndex==1){
                        //roadsL[]에서 �����으로 하나
                        const randomElement = this.roadsL[Math.floor(Math.random() * array.length)];
                        car = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                        car.position.set(randomElement.x, 0.5, randomElement.z); 
                        car.direction = 'south'; 
                    } else if(roadIndex==2){
                        const randomElement = this.roadsT[Math.floor(Math.random()* array.length)];
                        car = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                        car.position.set(randomElement.x, 0.5, randomElement.z);
                        car.direction = 'west';

                    }else{
                        const randomElement = this.roadsB[Math.floor(Math.random()* array.length)];
                        car = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                        car.position.set(randomElement.x, 0.5, randomElement.z);
                        car.direction = 'east';

                    }
                    cars.push(car);
                    this.mesh.add(car);
                }
            }
            animateCar(){
                cars.forEach(car => {
                    if(car.direction=='north'){
                        car.position.z += 0.5;
                        
                    } else if(car.direction=='south'){
                        car.position.z -= 0.5;
                        
                    } else if(car.direction=='west'){
                        car.position.x -= 0.5;
                        
                    } else{
                        car.position.x += 0.5;
                    }


                    // 교차로에 도달했는지 확인 (정확한 교차로 좌표와 비교)
                    
                    for(let intersection of this.intersectionLB){
                        if(intersection.position.distanceTo(car.position)<1){
                            car.position.x = intersection.x;  // 교차로 중심으로 위치 보정
                            car.position.z = intersection.z;  // 교차로 중심으로 위치 보정
                            // 새로운 방향 선택 (왔던 방향을 제외하고)
                            const previousDirection = car.direction;
                            car.direction = chooseDirection(car.direction);

                            // 방향이 즉시 반영될 수 있도록 바로 위치 업데이트
                            switch (car.direction) {
                                case 'north':
                                    car.position.z += 0.5;
                                    break;
                                case 'south':
                                    car.position.z -= 0.5;
                                    break;
                                case 'east':
                                    car.position.x += 0.5;
                                    break;
                                case 'west':
                                    car.position.x -= 0.5;
                                    break;
                            }

                            
                            }
                        }
                        for(let intersection of this.intersectionBB){
                        if(intersection.position.distanceTo(car.position)<1){
                            console.log('Crash!');
                            car.position.set(randomElement.x, 0.5, randomElement.z);
                        }
                        }
                        for(let intersection of this.intersectionTT){
                            if(intersection.position.distanceTo(car.position)<1){
                                console.log('Crash!');
                                car.position.set(randomElement.x, 0.5, randomElement.z);
                            }
                        }
                });
            
            
            }

            // 교차로에서 방향을 선택하는 함수
            chooseDirection(currentDirection){
                let directions = ['north', 'south', 'east', 'west'];
                const opposite = {
                    'north': 'south',
                    'south': 'north',
                    'east': 'west',
                    'west': 'east',
                };

                // 현재 방향의 반대 방향을 제외한 나머지 방향 중에서 선택
                const availableDirections = directions.filter(dir => dir !== opposite[currentDirection]);
                return availableDirections[Math.floor(Math.random() * availableDirections.length)];
            }
            
            
        }   

        
        class ChunkManager {
            constructor(gl) {
                this.chunks = new Map();
                this.chunkSize = 500;  // 청크 크기
                this.viewDistance = 3;  // 렌더링할 청크 범위
                this.gl = gl;
            }

            update(camera) {
                const chunkX = Math.floor(camera.position.x / this.chunkSize);
                const chunkZ = Math.floor(camera.position.z / this.chunkSize);

                for (let x = chunkX - this.viewDistance; x <= chunkX + this.viewDistance; x++) {
                    for (let z = chunkZ - this.viewDistance; z <= chunkZ + this.viewDistance; z++) {
                        const key = `${x},${z}`;
                        if (!this.chunks.has(key)) {
                            const chunk = new Chunk(x, z, this.chunkSize);
                            this.chunks.set(key, chunk);
                            this.gl.scene.add(chunk.mesh);
                            
                        }
                    }
                }
            }
        }

        // Three.js 환경 설정
        let scene, camera, renderer, controls, chunkManager;

        function init() {
            // 씬 생성
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // 하늘색 배경

            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(100, 150, 200);

            // 렌더러 생성
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // OrbitControls 추가
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // 부드러운 움직임
            controls.dampingFactor = 0.05;

            // 조명 추가
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(0, 200, 100).normalize();
            scene.add(light);

            // ChunkManager 초기화
            chunkManager = new ChunkManager({ scene });  // ChunkManager에 Three.js 씬 전달

            // 리사이즈 이벤트 처리
            window.addEventListener('resize', onWindowResize, false);

            // 애니메이션 루프 시작
            animate();
        }

        // 창 크기 변경 시 처리
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            // 청크 업데이트
            chunkManager.update(camera);

            // 컨트롤 업데이트
            controls.update();

            // 렌더링
            renderer.render(scene, camera);
        }

        // 초기화 함수 호출
        init();
    </script>
</body>
</html>
