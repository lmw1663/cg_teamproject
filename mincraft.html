<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Terrain with Orbit Controls and MV.js</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
    <!-- Three.js 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
    <!-- MV.js 파일 -->
    <script type="text/javascript" src="MV.js"></script>
    <script type="importmap">
        {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
        }
        </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // Perlin Noise 클래스 정의 (이전과 동일)
        class PerlinNoise {
            constructor() {
                this.permutation = [];
                this.init();
            }

            init() {
                for (let i = 0; i < 256; i++) {
                    this.permutation[i] = Math.floor(Math.random() * 256);
                }
                this.permutation = this.permutation.concat(this.permutation);
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y, z) {
                const floorX = Math.floor(x);
                const floorY = Math.floor(y);
                const floorZ = Math.floor(z);

                const X = floorX & 255;
                const Y = floorY & 255;
                const Z = floorZ & 255;

                x -= floorX;
                y -= floorY;
                z -= floorZ;

                const u = this.fade(x);
                const v = this.fade(y);
                const w = this.fade(z);

                const A = this.permutation[X] + Y;
                const AA = this.permutation[A] + Z;
                const AB = this.permutation[A + 1] + Z;
                const B = this.permutation[X + 1] + Y;
                const BA = this.permutation[B] + Z;
                const BB = this.permutation[B + 1] + Z;

                return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.permutation[AA], x, y, z),
                    this.grad(this.permutation[BA], x - 1, y, z)),
                    this.lerp(u, this.grad(this.permutation[AB], x, y - 1, z),
                        this.grad(this.permutation[BB], x - 1, y - 1, z))),
                    this.lerp(v, this.lerp(u, this.grad(this.permutation[AA + 1], x, y, z - 1),
                        this.grad(this.permutation[BA + 1], x - 1, y, z - 1)),
                        this.lerp(u, this.grad(this.permutation[AB + 1], x, y - 1, z - 1),
                            this.grad(this.permutation[BB + 1], x - 1, y - 1, z - 1))));
            }
        }
        // Chunk 클래스: 하나의 지형 조각을 나타냄
        class Chunk {
            constructor(x, z, size, noise) {
                this.x = x;
                this.z = z;
                this.size = size;
                this.noise = noise;
                this.mesh = this.generateTerrain();  // 지형 생성 후 Three.js Mesh로 반환
            }

            // 지형 생성 함수 (Perlin 노이즈 기반으로 지형의 높이를 생성)
            generateTerrain() {
                const geometry = new THREE.PlaneGeometry(this.size, this.size, this.size, this.size);
                geometry.rotateX(-Math.PI / 2); // 평면을 위로 향하게

                const vertices = geometry.attributes.position.array;

                for (let i = 0; i < vertices.length; i += 3) {
                    const x = this.x + vertices[i] / 10;
                    const z = this.z + vertices[i + 2] / 10;
                    const height = this.noise.noise(x, 0, z) * 50;  // Perlin 노이즈로 높이 설정
                    vertices[i + 1] = height;
                }

                geometry.computeVertexNormals(); // 지형을 위한 법선 계산

                const material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                return new THREE.Mesh(geometry, material);
            }
        }

        // ChunkManager 클래스: 여러 개의 Chunk를 관리
        class ChunkManager {
            constructor(gl, noise) {
                this.chunks = new Map();  // 생성된 청크를 저장
                this.chunkSize = 16;      // 청크의 크기
                this.viewDistance = 10;    // 카메라 주변 몇 청크 범위까지 생성할지
                this.noise = noise;
                this.gl = gl;
            }

            // 카메라 위치에 따라 청크를 업데이트하고, 보이는 영역에만 청크를 생성
            update(camera) {
                // 카메라의 현재 좌표를 청크 좌표로 변환
                const chunkX = Math.floor(camera.position.x / this.chunkSize);
                const chunkZ = Math.floor(camera.position.z / this.chunkSize);

                // 카메라의 viewDistance 범위 내에서 청크 생성
                for (let x = chunkX - this.viewDistance; x <= chunkX + this.viewDistance; x++) {
                    for (let z = chunkZ - this.viewDistance; z <= chunkZ + this.viewDistance; z++) {
                        const key = `${x},${z}`;  // 청크의 고유 키

                        // 해당 청크가 아직 생성되지 않았으면 새로운 청크 생성
                        if (!this.chunks.has(key)) {
                            const chunk = new Chunk(x * this.chunkSize, z * this.chunkSize, this.chunkSize, this.noise);
                            this.chunks.set(key, chunk);
                            this.gl.scene.add(chunk.mesh);  // 씬에 새로 생성한 청크 추가

                            // 청크 생성 좌표를 콘솔에 출력
                            console.log(`Chunk created at: x = ${x * this.chunkSize}, z = ${z * this.chunkSize}`);
                        }
                    }
                }
            }
        }

        class Camera {
            constructor(camera, speed = 1) {
                this.camera = camera;
                this.speed = speed;  // 카메라 이동 속도
                this.moveForward = false;
                this.moveBackward = false;
                this.moveLeft = false;
                this.moveRight = false;
                this.pitch = 0;            // 상하 시점 각도
                this.yaw = -Math.PI / 2;   // 좌우 시점 각도 (기본값은 -90도, 즉 정면)
                
                // 카메라가 바라보는 시점 좌표, THREE.Vector3 객체로 초기화
                this.lookAtPoint = new THREE.Vector3(100, 100, 100);  // 초기 시점은 (150, 150, 150)

                
                // 키보드 입력 이벤트 등록
                window.addEventListener('keydown', (event) => this.onKeyDown(event));
                window.addEventListener('keyup', (event) => this.onKeyUp(event));

                // 1초마다 카메라 위치를 콘솔에 출력
                setInterval(() => {
                    console.log(`Camera Position: x = ${this.camera.position.x}, y = ${this.camera.position.y}, z = ${this.camera.position.z}`);
                }, 1000);

                setInterval(() => {
                    console.log(`Camera lookAtPoint: x = ${this.lookAtPoint.x}, y = ${this.lookAtPoint.y}, z = ${this.lookAtPoint.z}`);
                }, 1000);
            }

            onKeyDown(event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        this.moveForward = true;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        this.moveBackward = true;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        this.moveLeft = true;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        this.moveRight = true;
                        break;
                }
            }

            onKeyUp(event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        this.moveForward = false;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        this.moveBackward = false;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        this.moveLeft = false;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        this.moveRight = false;
                        break;
                }
            }

            update() {
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction); // 카메라가 보는 방향


                // 위치 변화 및 시점 변화 동기화
                const moveOffset = new THREE.Vector3(); // 이동량을 저장하는 벡터


                // 카메라의 시점에 따라 x와 z 방향으로 이동
                if (this.moveForward) {
                    moveOffset.x += direction.x * this.speed;
                    moveOffset.z += direction.z * this.speed;
                }
                if (this.moveBackward) {
                    moveOffset.x -= direction.x * this.speed;
                    moveOffset.z -= direction.z * this.speed;
                }

                // 왼쪽/오른쪽 이동 (카메라의 오른쪽 벡터 사용)
                const right = new THREE.Vector3();
                right.crossVectors(this.camera.up, direction).normalize(); // 카메라의 오른쪽 방향

                if (this.moveLeft) {
                    moveOffset.x += right.x * this.speed;
                    moveOffset.z += right.z * this.speed;
                }
                if (this.moveRight) {
                    moveOffset.x -= right.x * this.speed;
                    moveOffset.z -= right.z * this.speed;
                }

                // 카메라 위치에 이동량 적용
                this.camera.position.add(moveOffset);
                // 시점도 동일하게 이동
                this.lookAtPoint.add(moveOffset);
                // // 카메라 위치와 시점 좌표를 시각적으로 표시할 정사각형(정육면체)
                const geometry = new THREE.BoxGeometry(20, 20, 20);
                // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // 카메라 위치 표시용 (녹색)
                const lookAtMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // 시점 표시용 (빨간색)
                
                // // 카메라 위치 정사각형
                // this.cameraPositionBox = new THREE.Mesh(geometry, material);
                this.lookAtPositionBox = new THREE.Mesh(geometry, lookAtMaterial);

                // // 씬에 추가
                // scene.add(this.cameraPositionBox);
                //scene.add(this.lookAtPositionBox);
                // // 카메라 위치에 있는 정사각형을 카메라 위치에 맞게 업데이트
                // this.cameraPositionBox.position.copy(this.camera.position);
                
                // // 카메라 시점 좌표에 있는 정사각형을 시점 좌표에 맞게 업데이트
                this.lookAtPositionBox.position.copy(this.lookAtPoint);

                this.camera.lookAt(this.lookAtPoint);
                // const direction = new THREE.Vector3();
        
                // if (this.moveForward) direction.z -= this.speed;
                // if (this.moveBackward) direction.z += this.speed;
                // if (this.moveLeft) direction.x -= this.speed;
                // if (this.moveRight) direction.x += this.speed;

                // // 카메라의 방향에 따라 이동
                // this.camera.position.add(direction);

                    }
                }
        // 직사각형(박스)을 추가하는 함수
        function createRectangle() {
            const geometry = new THREE.BoxGeometry(100, 100, 100); // 크기 (3, 5, 5)의 박스
            const material = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // 빨간색 재질
            const rectangle = new THREE.Mesh(geometry, material);

            rectangle.position.set(0, 0, 0); // 좌표 (0, 0, 0)에 위치

            scene.add(rectangle); // 씬에 직사각형 추가
        }

        // Three.js 환경 설정
        let scene, camera, renderer, controls, terrain, chunkmanager;
        const terrainSize = 200;
        const terrainResolution = 100;

        // 초기화 함수
        function init() {
            // 씬 생성
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // 하늘색 배경

            // THREE.PerspectiveCamera 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(150, 150, 150); // 초기 카메라 위치


            // 렌더러 생성
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // OrbitControls 추가
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // 부드러운 움직임
            controls.dampingFactor = 0.05;
            
            
            //createRectangle();

            // 카메라 이동을 처리할 객체 생성
             const playerCamera = new Camera(camera, 1); // 카메라 이동 속도 설정
            
            // 조명 추가
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(0, 200, 100).normalize();
            scene.add(light);


             // ChunkManager 초기화
            const noise = new PerlinNoise();
            chunkmanager= new ChunkManager({ scene }, noise);  // ChunkManager에 Three.js 씬 전달

            // 지형 생성
            createTerrain();

            // 리사이즈 이벤트 처리
            window.addEventListener('resize', onWindowResize, false);

            // 애니메이션 루프
            function animate() {
                requestAnimationFrame(animate);
                // 컨트롤 업데이트
                controls.update();
                // 카메라 업데이트
                playerCamera.update();

                // 청크 업데이트
                chunkmanager.update(camera);  // camera 대신 perspectiveCamera로 수정

                

                // 렌더링
                renderer.render(scene, camera);  // camera 대신 perspectiveCamera로 수정
            }

            // 애니메이션 루프 시작
            animate();
        }

        // 창 크기 변경 시 처리
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Perlin 노이즈 기반으로 지형 생성
        function createTerrain() {
            const noise = new PerlinNoise();
            const geometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainResolution, terrainResolution);
            geometry.rotateX(-Math.PI / 2); // 평면을 위로 향하게

            const vertices = geometry.attributes.position.array;

            // 각 정점에 대해 높이값 설정
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i] / 10;
                const z = vertices[i + 2] / 10;
                const height = noise.noise(x, 0, z) * 50; // Perlin 노이즈로 높이 결정
                vertices[i + 1] = height;
            }

            geometry.computeVertexNormals(); // 지형을 위한 법선 계산

            const material = new THREE.MeshLambertMaterial({ color: 0x8B4513, wireframe: false });
            terrain = new THREE.Mesh(geometry, material);
            scene.add(terrain);
        }

        

        // 초기화 함수 호출
        init();
    </script>
</body>
</html>
