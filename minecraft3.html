<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Random Terrain with Labels</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
    <!-- Three.js 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
    <script src="MV.js"></script>
    <script type="importmap">
        {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
        }
        </script>
</head>

<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const roadColor = 0x808080; // 회색 도로 색상
        const buildingAreaColors = [0x3b5998, 0x8b9dc3, 0xdfe3ee, 0xf7f7f7]; // 건물 밀집 구역 색상
        const cars = []; // 차 객체들을 저장할 배열
        const carSpeed = 0.05; // 차의 속도를 줄임
        let weatherState = 'clear';

        class Chunk {
            constructor(x, z, size) {
                this.x = x * size;  // 절대 좌표로 설정
                this.z = z * size;
                this.size = size;
                this.roadWidth = 3; // 도로 두께
                this.mesh = new THREE.Group(); // 청크 내 여러 Mesh를 그룹으로 관리
                this.buildings = [];
                this.cars = [];
                this.roadsL = [];
                this.roadsR = [];
                this.roadsT = [];
                this.roadsB = [];
                this.intersectionRT = new Set();
                this.intersectionRB = new Set();
                this.intersectionLB = new Set();
                this.intersectionLT = new Set();

                this.label = this.getRandomLabel();
                this.buildingColor = buildingAreaColors[this.label];

                this.generateChunk();
                this.createCars(5);  // 차 5대를 생성
            }

            getRandomLabel() {
                return Math.floor(Math.random() * 4);
            }

            generateChunk() {
                this.createBorderRoads();
                this.fillWithBuildingAreas();
                this.createIntersections();
            }

            createBorderRoads() {
                const roadMaterial = new THREE.MeshLambertMaterial({ color: roadColor });
                roadMaterial.receiveShadow = true;

                let roadGeometry = new THREE.PlaneGeometry(this.size, this.roadWidth);
                roadGeometry.rotateX(-Math.PI / 2);
                let road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.position.set(this.x + this.size / 2, 0.1, this.z + this.size - this.roadWidth / 2);
                this.mesh.add(road);

                road = road.clone();
                road.position.set(this.x + this.size / 2, 0.1, this.z + this.roadWidth / 2);
                this.mesh.add(road);

                roadGeometry = new THREE.PlaneGeometry(this.roadWidth, this.size);
                roadGeometry.rotateX(-Math.PI / 2);
                road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.position.set(this.x + this.roadWidth / 2, 0.1, this.z + this.size / 2);
                this.mesh.add(road);

                road = road.clone();
                road.position.set(this.x + this.size - this.roadWidth / 2, 0.1, this.z + this.size / 2);
                this.mesh.add(road);
            }

            fillWithBuildingAreas() {
                const buildingAreaMaterial = new THREE.MeshLambertMaterial({ color: this.buildingColor });
                const roadWidth = this.roadWidth;

                let currentX = this.x + roadWidth;
                let currentZ = this.z + roadWidth;
                const xValues = this.generateRandomSizes(this.size - 2 * roadWidth, 5, 40, 100);

                for (let i = 0; i < xValues.length; i++) {
                    const xWidth = xValues[i];
                    currentZ = this.z + roadWidth;

                    const zValues = this.generateRandomSizes(this.size - 2 * roadWidth, 5, 40, 100);
                    for (let j = 0; j < zValues.length; j++) {
                        const zDepth = zValues[j];

                        this.createRoads(currentX + roadWidth, currentZ, xWidth, zDepth, roadWidth);

                        const buildingAreaGeometry = new THREE.PlaneGeometry(xWidth - 2 * roadWidth, zDepth - 2 * roadWidth);
                        buildingAreaGeometry.rotateX(-Math.PI / 2);
                        const buildingArea = new THREE.Mesh(buildingAreaGeometry, buildingAreaMaterial);
                        buildingArea.position.set(currentX + xWidth / 2, 0.1, currentZ + zDepth / 2);
                        this.mesh.add(buildingArea);

                        currentZ += zDepth;
                    }

                    currentX += xWidth;
                }
            }

            createRoads(x, z, width, depth, roadWidth) {
                const roadGeometryX = new THREE.PlaneGeometry(width, roadWidth);
                const roadGeometryZ = new THREE.PlaneGeometry(roadWidth, depth - 2 * roadWidth);

                roadGeometryX.rotateX(-Math.PI / 2);
                roadGeometryZ.rotateX(-Math.PI / 2);

                const topRoad = new THREE.Mesh(roadGeometryX, new THREE.MeshLambertMaterial({ color: 0xcf3213 }));
                topRoad.position.set(x + width / 2 - roadWidth, 0.1, z + depth - roadWidth / 2);
                this.mesh.add(topRoad);
                this.roadsT.push({ x: x + width / 2 - roadWidth, z: z + depth - roadWidth / 2 });

                const bottomRoad = new THREE.Mesh(roadGeometryX, new THREE.MeshLambertMaterial({ color: 0xfcba03 }));
                bottomRoad.position.set(x + width / 2 - roadWidth, 0.1, z + roadWidth / 2);
                this.mesh.add(bottomRoad);
                this.roadsB.push({ x: x + width / 2 - roadWidth, z: z + roadWidth / 2 });

                const leftRoad = new THREE.Mesh(roadGeometryZ, new THREE.MeshLambertMaterial({ color: 0x0fd166 }));
                leftRoad.position.set(x + width - 3 * roadWidth / 2, 0.1, z + depth / 2);
                this.mesh.add(leftRoad);
                this.roadsL.push({ x: x + width - 3 * roadWidth / 2, z: z + depth / 2 });

                const rightRoad = new THREE.Mesh(roadGeometryZ, new THREE.MeshLambertMaterial({ color: 0x1c23ad }));
                rightRoad.position.set(x - roadWidth / 2, 0.1, z + depth / 2);
                this.mesh.add(rightRoad);
                this.roadsR.push({ x: x - roadWidth / 2, z: z + depth / 2 });
            }

            createIntersections() {
                const intersectionMaterial = new THREE.MeshLambertMaterial({ color: 0x11311d });
                const intersectionGeometry = new THREE.BoxGeometry(this.roadWidth, 0.1, this.roadWidth);

                for (let r of this.roadsR) {
                    for (let t of this.roadsT) {
                        if (Math.abs(r.x - t.x) < 1 && Math.abs(r.z - t.z) < 1) {
                            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                            intersection.position.set(r.x, 0.1, r.z);
                            this.mesh.add(intersection);
                            this.intersectionRT.add(intersection);
                        }
                    }
                }
            }

            generateRandomSizes(sum, count, min, max) {
                const sizes = [];
                let total = 0;

                for (let i = 0; i < count; i++) {
                    sizes.push(min);
                    total += min;
                }

                let remaining = sum - total;

                while (remaining > 0) {
                    for (let i = 0; i < count && remaining > 0; i++) {
                        const add = Math.min(remaining, Math.floor(Math.random() * (max - min + 1)));
                        sizes[i] += add;
                        remaining -= add;
                    }
                }

                return sizes;
            }

            // 랜덤으로 차 생성
            createCars(numberOfCars) {
                for (let i = 0; i < numberOfCars; i++) {
                    const roadIndex = Math.floor(Math.random() * 4);
                    let car;
                    
                    if (roadIndex === 0 && this.roadsR.length > 0) {
                        const randomRoad = this.roadsR[Math.floor(Math.random() * this.roadsR.length)];
                        car = this.createCar(randomRoad.x, randomRoad.z);
                        car.direction = 'west';
                    } else if (roadIndex === 1 && this.roadsL.length > 0) {
                        const randomRoad = this.roadsL[Math.floor(Math.random() * this.roadsL.length)];
                        car = this.createCar(randomRoad.x, randomRoad.z);
                        car.direction = 'east';
                    } else if (roadIndex === 2 && this.roadsT.length > 0) {
                        const randomRoad = this.roadsT[Math.floor(Math.random() * this.roadsT.length)];
                        car = this.createCar(randomRoad.x, randomRoad.z);
                        car.direction = 'north';
                    } else if (this.roadsB.length > 0) {
                        const randomRoad = this.roadsB[Math.floor(Math.random() * this.roadsB.length)];
                        car = this.createCar(randomRoad.x, randomRoad.z);
                        car.direction = 'south';
                    }

                    cars.push(car);
                    this.mesh.add(car);
                }
            }

            // 차 객체 생성
            createCar(x, z) {
                const car = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                car.position.set(x, 0.5, z);
                return car;
            }

            // 차 이동 로직
            moveCars() {
                cars.forEach(car => {
                    switch (car.direction) {
                        case 'north':
                            car.position.z -= carSpeed;
                            break;
                        case 'south':
                            car.position.z += carSpeed;
                            break;
                        case 'east':
                            car.position.x += carSpeed;
                            break;
                        case 'west':
                            car.position.x -= carSpeed;
                            break;
                    }

                    // 도로 경계를 넘지 않도록 제한
                    if (car.position.x < this.x || car.position.x > this.x + this.size || car.position.z < this.z || car.position.z > this.z + this.size) {
                        // 도로 밖으로 벗어나면 방향을 반대로 바꿈
                        switch (car.direction) {
                            case 'north':
                                car.direction = 'south';
                                break;
                            case 'south':
                                car.direction = 'north';
                                break;
                            case 'east':
                                car.direction = 'west';
                                break;
                            case 'west':
                                car.direction = 'east';
                                break;
                        }
                    }
                });
            }
        }

        class ChunkManager {
            constructor(gl) {
                this.chunks = new Map();
                this.chunkSize = 500;
                this.viewDistance = 3;
                this.gl = gl;
            }

            update(camera) {
                const chunkX = Math.floor(camera.position.x / this.chunkSize);
                const chunkZ = Math.floor(camera.position.z / this.chunkSize);

                for (let x = chunkX - this.viewDistance; x <= chunkX + this.viewDistance; x++) {
                    for (let z = chunkZ - this.viewDistance; z <= chunkZ + this.viewDistance; z++) {
                        const key = `${x},${z}`;
                        if (!this.chunks.has(key)) {
                            const chunk = new Chunk(x, z, this.chunkSize);
                            this.chunks.set(key, chunk);
                            this.gl.scene.add(chunk.mesh);
                        }
                    }
                }
            }
        }

        // Three.js 환경 설정
        let scene, camera, renderer, controls, chunkManager;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(100, 150, 200);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(0, 200, 100).normalize();
            scene.add(light);

            chunkManager = new ChunkManager({ scene });

            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            chunkManager.update(camera);
            chunkManager.chunks.forEach(chunk => chunk.moveCars());

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
