<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Terrain with Orbit Controls and MV.js</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
    <!-- Three.js 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
    <!-- MV.js 파일 -->
    <script type="text/javascript" src="MV.js"></script>
    <script type="importmap">
        {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
        }
        </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // Perlin Noise 클래스 정의 (이전과 동일)
        class PerlinNoise {
            constructor() {
                this.permutation = [];
                this.init();
            }

            init() {
                for (let i = 0; i < 256; i++) {
                    this.permutation[i] = Math.floor(Math.random() * 256);
                }
                this.permutation = this.permutation.concat(this.permutation);
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y, z) {
                const floorX = Math.floor(x);
                const floorY = Math.floor(y);
                const floorZ = Math.floor(z);

                const X = floorX & 255;
                const Y = floorY & 255;
                const Z = floorZ & 255;

                x -= floorX;
                y -= floorY;
                z -= floorZ;

                const u = this.fade(x);
                const v = this.fade(y);
                const w = this.fade(z);

                const A = this.permutation[X] + Y;
                const AA = this.permutation[A] + Z;
                const AB = this.permutation[A + 1] + Z;
                const B = this.permutation[X + 1] + Y;
                const BA = this.permutation[B] + Z;
                const BB = this.permutation[B + 1] + Z;

                return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.permutation[AA], x, y, z),
                    this.grad(this.permutation[BA], x - 1, y, z)),
                    this.lerp(u, this.grad(this.permutation[AB], x, y - 1, z),
                        this.grad(this.permutation[BB], x - 1, y - 1, z))),
                    this.lerp(v, this.lerp(u, this.grad(this.permutation[AA + 1], x, y, z - 1),
                        this.grad(this.permutation[BA + 1], x - 1, y, z - 1)),
                        this.lerp(u, this.grad(this.permutation[AB + 1], x, y - 1, z - 1),
                            this.grad(this.permutation[BB + 1], x - 1, y - 1, z - 1))));
            }

            // 옥타브 방식의 노이즈 생성 (여러 주파수와 진폭을 더해 디테일 추가)
            octaveNoise(x, y, z, octaves, persistence) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;  // 정규화를 위한 값

                for (let i = 0; i < octaves; i++) {
                    total += this.noise(x * frequency, y * frequency, z * frequency) * amplitude;

                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }

                return total / maxValue;
            }
        }

        class Chunk {
            constructor(x, z, size, noise, neighbors = {}) {
                this.x = x * size;  // 절대 좌표로 설정
                this.z = z * size;
                this.size = size;
                this.noise = noise;
                this.neighbors = neighbors;  // 이웃 청크 정보
                this.mesh = this.generateTerrain();
            }

            generateTerrain() {
                const geometry = new THREE.PlaneGeometry(this.size, this.size, 16, 16);
                geometry.rotateX(-Math.PI / 2);  // 평면을 위로 향하게 회전

                const vertices = geometry.attributes.position.array;

                for (let i = 0; i < vertices.length; i += 3) {
                    const localX = vertices[i] / 10;  // 로컬 좌표
                    const localZ = vertices[i + 2] / 10;
                    const worldX = this.x + vertices[i] / 10;  // 절대 좌표
                    const worldZ = this.z + vertices[i + 2] / 10;

                    let height;

                    // 경계에 있는 경우 이웃한 청크의 높이 값을 참조
                    if (this.isOnBorder(i, vertices)) {
                        height = this.getHeightFromNeighbor(localX, localZ);  // 이웃 청크로부터 높이 값을 가져옴
                    } else {
                        const peakNoise = this.noise.octaveNoise(worldX, 0, worldZ, 1, 0.1) * 2;
                        const erosionNoise = this.noise.octaveNoise(worldX, 0, worldZ, 6, 0.9) * 50;
                        height = erosionNoise + peakNoise;
                    }

                    vertices[i + 1] = height;  // 높이값 설정
                }

                geometry.computeVertexNormals();  // 법선 계산
                const material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(this.x, 0, this.z);
                return mesh;
            }

            // 경계에 있는지 확인하는 함수
            isOnBorder(index, vertices) {
                const localX = vertices[index];
                const localZ = vertices[index + 2];

                return (
                    localX === 0 || localX === this.size ||
                    localZ === 0 || localZ === this.size
                );
            }

            // 이웃 청크로부터 높이 값을 가져오는 함수
            getHeightFromNeighbor(localX, localZ) {
                // 이웃 청크 정보가 있으면 해당 청크의 높이를 가져옴
                if (localX === 0 && this.neighbors.left) {
                    return this.neighbors.left.getHeightAt(this.size, localZ);
                } else if (localX === this.size && this.neighbors.right) {
                    return this.neighbors.right.getHeightAt(0, localZ);
                } else if (localZ === 0 && this.neighbors.top) {
                    return this.neighbors.top.getHeightAt(localX, this.size);
                } else if (localZ === this.size && this.neighbors.bottom) {
                    return this.neighbors.bottom.getHeightAt(localX, 0);
                }

                // 이웃 청크가 없으면 자체적으로 계산
                const worldX = this.x + localX;
                const worldZ = this.z + localZ;
                const peakNoise = this.noise.octaveNoise(worldX, 0, worldZ, 1, 0.1) * 2;
                const erosionNoise = this.noise.octaveNoise(worldX, 0, worldZ, 6, 0.9) * 50;
                return erosionNoise + peakNoise;
            }

            // 특정 좌표에서 높이를 반환하는 함수
            getHeightAt(localX, localZ) {
                const worldX = this.x + localX;
                const worldZ = this.z + localZ;
                const peakNoise = this.noise.octaveNoise(worldX, 0, worldZ, 1, 0.1) * 2;
                const erosionNoise = this.noise.octaveNoise(worldX, 0, worldZ, 6, 0.9) * 50;
                return erosionNoise + peakNoise;
            }
        }






        class ChunkManager {
            constructor(gl, noise) {
                this.chunks = new Map();
                this.chunkSize = 200;  // 청크 크기
                this.viewDistance = 1;  // 렌더링할 청크 범위
                this.noise = noise;
                this.gl = gl;
            }

            update(camera) {
                const chunkX = Math.floor(camera.position.x / this.chunkSize);
                const chunkZ = Math.floor(camera.position.z / this.chunkSize);

                for (let x = chunkX - this.viewDistance; x <= chunkX + this.viewDistance; x++) {
                    for (let z = chunkZ - this.viewDistance; z <= chunkZ + this.viewDistance; z++) {
                        const key = `${x},${z}`;
                        if (!this.chunks.has(key)) {
                            const neighbors = {
                                left: this.chunks.get(`${x - 1},${z}`),
                                right: this.chunks.get(`${x + 1},${z}`),
                                top: this.chunks.get(`${x},${z - 1}`),
                                bottom: this.chunks.get(`${x},${z + 1}`),
                            };

                            const chunk = new Chunk(x, z, this.chunkSize, this.noise, neighbors);
                            this.chunks.set(key, chunk);
                            this.gl.scene.add(chunk.mesh);
                        }
                    }
                }
            }
        }



        // Three.js 환경 설정
        let scene, camera, renderer, controls, terrain, chunkmanager;
        const terrainSize = 200;
        const terrainResolution = 100;

        // 초기화 함수
        function init() {
            // 씬 생성
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // 하늘색 배경

            // MV.js의 vec3, perspective, lookAt 사용
            const eye = vec3(100, 150, 200); // 카메라의 초기 위치
            const at = vec3(0, 0, 0);       // 카메라가 보는 지점
            const up = vec3(0, 1, 0);       // 카메라의 상단 방향

            // 카메라 설정 (MV.js의 lookAt, perspective 사용)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(eye[0], eye[1], eye[2]);

            // 렌더러 생성
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // OrbitControls 추가
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // 부드러운 움직임
            controls.dampingFactor = 0.05;
            
            // 조명 추가
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(0, 200, 100).normalize();
            scene.add(light);

             // ChunkManager 초기화
            const noise = new PerlinNoise();
            chunkmanager= new ChunkManager({ scene }, noise);  // ChunkManager에 Three.js 씬 전달

        
            // 리사이즈 이벤트 처리
            window.addEventListener('resize', onWindowResize, false);

            // 애니메이션 루프 시작
            animate();
        }

        // 창 크기 변경 시 처리
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Perlin 노이즈 기반으로 지형 생성
        function createTerrain() {
            const noise = new PerlinNoise();
            const geometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainResolution, terrainResolution);
            geometry.rotateX(-Math.PI / 2); // 평면을 위로 향하게

            const vertices = geometry.attributes.position.array;

            // 각 정점에 대해 높이값 설정
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i] / 10;
                const z = vertices[i + 2] / 10;
                const height = noise.noise(x, 0, z) * 50; // Perlin 노이즈로 높이 결정
                vertices[i + 1] = height;
            }

            geometry.computeVertexNormals(); // 지형을 위한 법선 계산

            const material = new THREE.MeshLambertMaterial({ color: 0x8B4513, wireframe: false });
            terrain = new THREE.Mesh(geometry, material);
            scene.add(terrain);
        }

        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            // 청크 업데이트
            chunkmanager.update(camera);

            // 컨트롤 업데이트
            controls.update();

            // 렌더링
            renderer.render(scene, camera);
        }

        // 초기화 함수 호출
        init();
    </script>
</body>
</html>
